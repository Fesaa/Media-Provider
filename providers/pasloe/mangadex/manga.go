package mangadex

import (
	"context"
	"fmt"
	"github.com/Fesaa/Media-Provider/db/models"
	"github.com/Fesaa/Media-Provider/http/menou"
	"github.com/Fesaa/Media-Provider/http/payload"
	"github.com/Fesaa/Media-Provider/providers/pasloe/core"
	"github.com/Fesaa/Media-Provider/services"
	"github.com/Fesaa/Media-Provider/utils"
	"github.com/rs/zerolog"
	"github.com/spf13/afero"
	"go.uber.org/dig"
	"path"
	"slices"
	"strconv"
)

const comicInfoNote = "This comicinfo.xml was auto generated by Media-Provider, with information from mangadex. Source code can be found here: https://github.com/Fesaa/Media-Provider/"
const metronInfoNote = "This metroninfo.xml was auto generated by Media-Provider, with information from mangadex. Source code can be found here: https://github.com/Fesaa/Media-Provider/"
const timeLayout = "2006-01-02T15:04:05Z07:00"
const genreTag = "genre"

func NewManga(scope *dig.Scope) core.Downloadable {
	var m *manga

	utils.Must(scope.Invoke(func(
		req payload.DownloadRequest, httpClient *menou.Client,
		repository Repository, markdownService services.MarkdownService,
		imageService services.ImageService, archiveService services.ArchiveService,
		fs afero.Afero,
	) {
		m = &manga{
			id:              req.Id,
			httpClient:      httpClient,
			repository:      repository,
			markdownService: markdownService,
			volumeMetadata:  make([]string, 0),
			imageService:    imageService,
			archiveService:  archiveService,
			fs:              fs,

			language: utils.MustHave(req.GetString(LanguageKey, "en")),
		}
		m.Core = core.New[ChapterSearchData](scope, "mangadex", m)
	}))

	return m
}

type manga struct {
	*core.Core[ChapterSearchData]
	id string

	httpClient      *menou.Client
	repository      Repository
	markdownService services.MarkdownService
	imageService    services.ImageService
	archiveService  services.ArchiveService
	fs              afero.Afero

	info     *MangaSearchData
	chapters ChapterSearchResponse

	coverFactory   CoverFactory
	volumeMetadata []string

	lastFoundChapter int
	lastFoundVolume  int
	foundLastVolume  bool
	foundLastChapter bool

	hasWarned          bool
	hasWarnedBlacklist bool
	hasNotifiedSub     bool

	language string
}

func (m *manga) Title() string {
	if m.info == nil {
		if m.TempTitle != "" {
			return m.TempTitle
		}

		return m.id
	}

	return m.info.Attributes.LangTitle(m.language)
}

func (m *manga) Provider() models.Provider {
	return m.Req.Provider
}

func (m *manga) RefUrl() string {
	if m.info == nil {
		return fmt.Sprintf("https://mangadex.org/title/%s/", m.Id())
	}

	return m.info.RefURL()
}

func (m *manga) All() []ChapterSearchData {
	return m.chapters.Data
}

func (m *manga) ContentList() []payload.ListContentData {
	if len(m.chapters.Data) == 0 {
		return nil
	}

	data := utils.GroupBy(m.chapters.Data, func(v ChapterSearchData) string {
		return v.Attributes.Volume
	})

	childrenFunc := func(chapters []ChapterSearchData) []payload.ListContentData {
		slices.SortFunc(chapters, func(a, b ChapterSearchData) int {
			if a.Attributes.Volume != b.Attributes.Volume {
				return (int)(b.Volume() - a.Volume())
			}
			return (int)(b.Chapter() - a.Chapter())
		})

		return utils.Map(chapters, func(chapter ChapterSearchData) payload.ListContentData {
			return payload.ListContentData{
				SubContentId: chapter.Id,
				Selected:     len(m.ToDownloadUserSelected) == 0 || slices.Contains(m.ToDownloadUserSelected, chapter.Id),
				Label: utils.Ternary(chapter.Attributes.Title == "",
					m.Title()+" "+chapter.Label(),
					chapter.Label()),
			}
		})
	}

	sortSlice := utils.Keys(data)
	slices.SortFunc(sortSlice, utils.SortFloats)

	out := make([]payload.ListContentData, 0, len(data))
	for _, volume := range sortSlice {
		chapters := data[volume]

		// Do not add No Volume label if there are no volumes
		if volume == "" && len(sortSlice) == 1 {
			out = append(out, childrenFunc(chapters)...)
			continue
		}

		out = append(out, payload.ListContentData{
			Label:    utils.Ternary(volume == "", "No Volume", fmt.Sprintf("Volume %s", volume)),
			Children: childrenFunc(chapters),
		})
	}
	return out
}

func (m *manga) ContentDir(chapter ChapterSearchData) string {
	if chapter.Attributes.Chapter == "" {
		return fmt.Sprintf("%s OneShot %s", m.Title(), chapter.Attributes.Title)
	}

	if _, err := strconv.ParseFloat(chapter.Attributes.Chapter, 32); err == nil {
		padded := utils.PadFloatFromString(chapter.Attributes.Chapter, 4)
		chDir := fmt.Sprintf("%s Ch. %s", m.Title(), padded)
		return chDir
	} else if chapter.Attributes.Chapter != "" { // Don't warm for empty chpt. They're expected to fail
		m.Log.Warn().Err(err).Str("chapter", chapter.Attributes.Chapter).Msg("unable to parse chpt number, not padding")
	}

	return fmt.Sprintf("%s Ch. %s", m.Title(), chapter.Attributes.Chapter)
}

func (m *manga) ContentPath(chapter ChapterSearchData) string {
	base := path.Join(m.Client.GetBaseDir(), m.GetBaseDir(), m.Title())
	if chapter.Attributes.Volume == "" {
		return path.Join(base, m.ContentDir(chapter))
	}
	return path.Join(base, m.volumeDir(chapter.Attributes.Volume), m.ContentDir(chapter))
}

func (m *manga) ContentKey(chapter ChapterSearchData) string {
	return chapter.Id
}

func (m *manga) ContentLogger(chapter ChapterSearchData) zerolog.Logger {
	builder := m.Log.With().
		Str("chapterId", chapter.Id).
		Str("chapter", chapter.Attributes.Chapter)

	if chapter.Attributes.Volume != "" {
		builder = builder.Str("volume", chapter.Attributes.Volume)
	}

	if chapter.Attributes.Title != "" {
		builder = builder.Str("title", chapter.Attributes.Title)
	}

	return builder.Logger()
}

func (m *manga) ContentUrls(ctx context.Context, chapter ChapterSearchData) ([]string, error) {
	imageInfo, err := m.repository.GetChapterImages(ctx, chapter.Id)
	if err != nil {
		return nil, err
	}
	return imageInfo.FullImageUrls(), nil
}

func (m *manga) DownloadContent(page int, chapter ChapterSearchData, url string) error {
	filePath := path.Join(m.ContentPath(chapter), fmt.Sprintf("page %s"+utils.Ext(url), utils.PadInt(page, 4)))
	if err := m.DownloadAndWrite(url, filePath); err != nil {
		return err
	}
	m.ImagesDownloaded++
	return nil
}

func (m *manga) volumeDir(v string) string {
	if v == "" {
		return fmt.Sprintf("%s Special", m.Title())
	}

	return fmt.Sprintf("%s Vol. %s", m.Title(), v)
}
