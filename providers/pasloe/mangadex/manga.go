package mangadex

import (
	"context"
	"fmt"
	"github.com/Fesaa/Media-Provider/db/models"
	"github.com/Fesaa/Media-Provider/http/payload"
	"github.com/Fesaa/Media-Provider/providers/pasloe/api"
	"github.com/Fesaa/Media-Provider/services"
	"github.com/Fesaa/Media-Provider/utils"
	"github.com/rs/zerolog"
	"go.uber.org/dig"
	"io"
	"net/http"
	"os"
	"path"
	"slices"
	"strconv"
	"time"
)

const comicInfoNote = "This comicinfo.xml was auto generated by Media-Provider, with information from mangadex. Source code can be found here: https://github.com/Fesaa/Media-Provider/"
const metronInfoNote = "This metroninfo.xml was auto generated by Media-Provider, with information from mangadex. Source code can be found here: https://github.com/Fesaa/Media-Provider/"
const timeLayout = "2006-01-02T15:04:05Z07:00"
const genreTag = "genre"

func NewManga(scope *dig.Scope) api.Downloadable {
	var m *manga

	utils.Must(scope.Invoke(func(
		req payload.DownloadRequest, httpClient *http.Client,
		repository Repository, markdownService services.MarkdownService,
		preferences models.Preferences, imageService services.ImageService,
	) {
		m = &manga{
			id:              req.Id,
			httpClient:      httpClient,
			repository:      repository,
			markdownService: markdownService,
			volumeMetadata:  make([]string, 0),
			preferences:     preferences,
			imageService:    imageService,

			language: utils.MustHave(req.GetString(LanguageKey, "en")),
		}
		m.DownloadBase = api.NewDownloadableFromBlock[ChapterSearchData](scope, "mangadex", m)
	}))

	return m
}

type manga struct {
	*api.DownloadBase[ChapterSearchData]
	id string

	httpClient      *http.Client
	repository      Repository
	markdownService services.MarkdownService
	preferences     models.Preferences
	imageService    services.ImageService

	info     *MangaSearchData
	chapters ChapterSearchResponse

	coverFactory   CoverFactory
	volumeMetadata []string

	lastFoundChapter int
	lastFoundVolume  int
	foundLastVolume  bool
	foundLastChapter bool

	hasWarned          bool
	hasWarnedBlacklist bool
	hasNotifiedSub     bool

	language string
}

func (m *manga) Title() string {
	if m.info == nil {
		if m.TempTitle != "" {
			return m.TempTitle
		}

		return m.id
	}

	return m.info.Attributes.LangTitle(m.language)
}

func (m *manga) Provider() models.Provider {
	return m.Req.Provider
}

func (m *manga) RefUrl() string {
	if m.info == nil {
		return fmt.Sprintf("https://mangadex.org/title/%s/", m.Id())
	}

	return m.info.RefURL()
}

func (m *manga) All() []ChapterSearchData {
	return m.chapters.Data
}

func (m *manga) ContentList() []payload.ListContentData {
	if len(m.chapters.Data) == 0 {
		return nil
	}

	data := utils.GroupBy(m.chapters.Data, func(v ChapterSearchData) string {
		return v.Attributes.Volume
	})

	childrenFunc := func(chapters []ChapterSearchData) []payload.ListContentData {
		slices.SortFunc(chapters, func(a, b ChapterSearchData) int {
			if a.Attributes.Volume != b.Attributes.Volume {
				return (int)(b.Volume() - a.Volume())
			}
			return (int)(b.Chapter() - a.Chapter())
		})

		return utils.Map(chapters, func(chapter ChapterSearchData) payload.ListContentData {
			return payload.ListContentData{
				SubContentId: chapter.Id,
				Selected:     len(m.ToDownloadUserSelected) == 0 || slices.Contains(m.ToDownloadUserSelected, chapter.Id),
				Label: utils.Ternary(chapter.Attributes.Title == "",
					m.Title()+" "+chapter.Label(),
					chapter.Label()),
			}
		})
	}

	sortSlice := utils.Keys(data)
	slices.SortFunc(sortSlice, utils.SortFloats)

	out := make([]payload.ListContentData, 0, len(data))
	for _, volume := range sortSlice {
		chapters := data[volume]

		// Do not add No Volume label if there are no volumes
		if volume == "" && len(sortSlice) == 1 {
			out = append(out, childrenFunc(chapters)...)
			continue
		}

		out = append(out, payload.ListContentData{
			Label:    utils.Ternary(volume == "", "No Volume", fmt.Sprintf("Volume %s", volume)),
			Children: childrenFunc(chapters),
		})
	}
	return out
}

func (m *manga) ContentDir(chapter ChapterSearchData) string {
	if chapter.Attributes.Chapter == "" {
		return fmt.Sprintf("%s OneShot %s", m.Title(), chapter.Attributes.Title)
	}

	if chpt, err := strconv.ParseFloat(chapter.Attributes.Chapter, 32); err == nil {
		chDir := fmt.Sprintf("%s Ch. %s", m.Title(), utils.PadFloat(chpt, 4))
		return chDir
	} else if chapter.Attributes.Chapter != "" { // Don't warm for empty chpt. They're expected to fail
		m.Log.Warn().Err(err).Str("chapter", chapter.Attributes.Chapter).Msg("unable to parse chpt number, not padding")
	}

	return fmt.Sprintf("%s Ch. %s", m.Title(), chapter.Attributes.Chapter)
}

func (m *manga) ContentPath(chapter ChapterSearchData) string {
	base := path.Join(m.Client.GetBaseDir(), m.GetBaseDir(), m.Title())
	if chapter.Attributes.Volume == "" {
		return path.Join(base, m.ContentDir(chapter))
	}
	return path.Join(base, m.volumeDir(chapter.Attributes.Volume), m.ContentDir(chapter))
}

func (m *manga) ContentKey(chapter ChapterSearchData) string {
	return chapter.Id
}

func (m *manga) ContentLogger(chapter ChapterSearchData) zerolog.Logger {
	builder := m.Log.With().
		Str("chapterId", chapter.Id).
		Str("chapter", chapter.Attributes.Chapter)

	if chapter.Attributes.Volume != "" {
		builder = builder.Str("volume", chapter.Attributes.Volume)
	}

	if chapter.Attributes.Title != "" {
		builder = builder.Str("title", chapter.Attributes.Title)
	}

	return builder.Logger()
}

func (m *manga) ContentUrls(ctx context.Context, chapter ChapterSearchData) ([]string, error) {
	imageInfo, err := m.repository.GetChapterImages(ctx, chapter.Id)
	if err != nil {
		return nil, err
	}
	return imageInfo.FullImageUrls(), nil
}

func (m *manga) DownloadContent(page int, chapter ChapterSearchData, url string) error {
	filePath := path.Join(m.ContentPath(chapter), fmt.Sprintf("page %s.jpg", utils.PadInt(page, 4)))
	if err := m.downloadAndWrite(url, filePath); err != nil {
		return err
	}
	m.ImagesDownloaded++
	return nil
}

func (m *manga) volumeDir(v string) string {
	if v == "" {
		return fmt.Sprintf("%s Special", m.Title())
	}

	return fmt.Sprintf("%s Vol. %s", m.Title(), v)
}

func (m *manga) download(url string, tryAgain ...bool) ([]byte, error) {
	resp, err := m.httpClient.Get(url)
	if err != nil {
		return nil, err
	}
	defer func(Body io.ReadCloser) {
		if err = Body.Close(); err != nil {
			m.Log.Warn().Err(err).Msg("error closing body")
		}
	}(resp.Body)

	if resp.StatusCode == http.StatusOK {
		data, err := io.ReadAll(resp.Body)
		if err != nil {
			return nil, err
		}

		return data, nil
	}

	if resp.StatusCode != http.StatusTooManyRequests {
		return nil, fmt.Errorf("bad status: %s", resp.Status)
	}

	if len(tryAgain) > 0 && !tryAgain[0] {
		m.Log.Error().Msg("Reached rate limit, after sleeping. What is going on?")
		return nil, fmt.Errorf("bad status: %s", resp.Status)
	}

	retryAfter := resp.Header.Get("X-RateLimit-Retry-After")

	var d time.Duration
	if unix, err := strconv.ParseInt(retryAfter, 10, 64); err == nil {
		t := time.Unix(unix, 0)
		d = time.Until(t)
	} else {
		d = time.Minute
	}

	m.Log.Warn().Str("retryAfter", retryAfter).Dur("sleeping_for", d).Msg("Hit rate limit, try again after it's over")

	time.Sleep(d)
	return m.download(url, false)
}

func (m *manga) downloadAndWrite(url string, path string, tryAgain ...bool) error {
	data, err := m.download(url, tryAgain...)
	if err != nil {
		return err
	}

	if err = os.WriteFile(path, data, 0755); err != nil {
		return err
	}

	return nil
}
