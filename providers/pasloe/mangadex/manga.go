package mangadex

import (
	"fmt"
	"github.com/Fesaa/Media-Provider/comicinfo"
	"github.com/Fesaa/Media-Provider/db/models"
	"github.com/Fesaa/Media-Provider/http/payload"
	"github.com/Fesaa/Media-Provider/providers/pasloe/api"
	"github.com/Fesaa/Media-Provider/utils"
	"github.com/Fesaa/go-metroninfo"
	mapset "github.com/deckarep/golang-set/v2"
	"github.com/rs/zerolog"
	"go.uber.org/dig"
	"io"
	"net/http"
	"os"
	"path"
	"regexp"
	"slices"
	"strconv"
	"strings"
	"time"
)

const comicInfoNote = "This comicinfo.xml was auto generated by Media-Provider, with information from mangadex. Source code can be found here: https://github.com/Fesaa/Media-Provider/"
const metronInfoNote = "This metroninfo.xml was auto generated by Media-Provider, with information from mangadex. Source code can be found here: https://github.com/Fesaa/Media-Provider/"
const timeLayout = "2006-01-02T15:04:05Z07:00"
const genreTag = "genre"

var contentRegex = regexp.MustCompile(".* (?:Ch|Vol)\\. ([\\d|\\.]+).cbz")

func NewManga(scope *dig.Scope) api.Downloadable {
	var block *manga

	utils.Must(scope.Invoke(func(
		req payload.DownloadRequest, client api.Client, httpClient *http.Client,
		log zerolog.Logger, repository *Repository,
	) {
		block = &manga{
			id:             req.Id,
			httpClient:     httpClient,
			repository:     repository,
			volumeMetadata: make([]string, 0),
		}
		d := api.NewDownloadableFromBlock[ChapterSearchData](req, block, client, log.With().Str("handler", "mangadex").Logger())
		block.DownloadBase = d
	}))

	return block
}

type manga struct {
	*api.DownloadBase[ChapterSearchData]
	id string

	httpClient *http.Client
	repository *Repository

	info     *MangaSearchData
	chapters ChapterSearchResponse

	coverFactory   CoverFactory
	volumeMetadata []string

	totalChapters    int
	totalVolumes     int
	foundLastVolume  bool
	foundLastChapter bool

	hasWarned bool
}

func (m *manga) Title() string {
	if m.info == nil {
		return m.id
	}

	return m.info.Attributes.EnTitle()
}

func (m *manga) Provider() models.Provider {
	return m.Req.Provider
}

func (m *manga) LoadInfo() chan struct{} {
	out := make(chan struct{})
	go func() {
		mangaInfo, err := m.repository.GetManga(m.id)
		if err != nil {
			m.Log.Error().Err(err).Msg("error while loading manga info")
			m.Cancel()
			return
		}
		m.info = &mangaInfo.Data

		chapters, err := m.repository.GetChapters(m.id)
		if err != nil || chapters == nil {
			m.Log.Error().Err(err).Msg("error while loading manga info")
			m.Cancel()
			return
		}
		m.chapters = chapters.FilterOneEnChapter()

		volumes := mapset.NewSet[string]()
		chapterSet := mapset.NewSet[string]()
		m.foundLastVolume = false
		for _, ch := range m.chapters.Data {
			if ch.Attributes.Volume == m.info.Attributes.LastVolume && m.info.Attributes.LastVolume != "" {
				m.foundLastVolume = true
			}
			if ch.Attributes.Chapter == m.info.Attributes.LastChapter && m.info.Attributes.LastChapter != "" {
				m.foundLastChapter = true
			}
			if _, err = strconv.ParseInt(ch.Attributes.Volume, 10, 64); err == nil {
				volumes.Add(ch.Attributes.Volume)
			} else {
				m.Log.Trace().Str("volume", ch.Attributes.Volume).Str("chapter", ch.Attributes.Chapter).
					Msg("not adding chapter, as Volume string isn't an int")
			}

			if _, err = strconv.ParseInt(ch.Attributes.Chapter, 10, 64); err == nil {
				chapterSet.Add(ch.Attributes.Chapter)
			} else {
				m.Log.Trace().Str("volume", ch.Attributes.Volume).Str("chapter", ch.Attributes.Chapter).
					Msg("not adding chapter, as Chapter string isn't an int")
			}
		}
		m.totalVolumes = volumes.Cardinality()
		m.totalChapters = chapterSet.Cardinality()

		covers, err := m.repository.GetCoverImages(m.id)
		if err != nil || covers == nil {
			m.Log.Warn().Err(err).Msg("error while loading manga coverFactory, ignoring")
			m.coverFactory = func(_ string) (string, bool) {
				return "", false
			}
		} else {
			m.coverFactory = covers.GetCoverFactory(m.id)
		}

		close(out)
	}()
	return out
}

func (m *manga) All() []ChapterSearchData {
	return m.chapters.Data
}

func (m *manga) GetInfo() payload.InfoStat {
	volumeDiff := m.ImagesDownloaded - m.LastRead
	timeDiff := max(time.Since(m.LastTime).Seconds(), 1)
	speed := max(int64(float64(volumeDiff)/timeDiff), 1)
	m.LastRead = m.ImagesDownloaded
	m.LastTime = time.Now()

	return payload.InfoStat{
		Provider: models.MANGADEX,
		Id:       m.id,
		Name: func() string {
			title := m.Title()
			if title == m.id && m.TempTitle != "" {
				return m.TempTitle
			}
			return title
		}(),
		RefUrl: func() string {
			if m.info == nil {
				return ""
			}
			return m.info.RefURL()
		}(),
		Size:        strconv.Itoa(len(m.ToDownload)) + " Chapters",
		Downloading: m.Wg != nil,
		Progress:    utils.Percent(int64(m.ContentDownloaded), int64(len(m.ToDownload))),
		SpeedType:   payload.IMAGES,
		Speed:       payload.SpeedData{T: time.Now().Unix(), Speed: speed},
		DownloadDir: m.GetDownloadDir(),
	}
}

func (m *manga) ContentDir(chapter ChapterSearchData) string {
	if chpt, err := strconv.ParseFloat(chapter.Attributes.Chapter, 32); err == nil {
		chDir := fmt.Sprintf("%s Ch. %s", m.Title(), utils.PadFloat(chpt, 4))
		return chDir
	} else if chapter.Attributes.Chapter != "" { // Don't warm for empty chpt. They're expected to fail
		m.Log.Warn().Err(err).Str("chapter", chapter.Attributes.Chapter).Msg("unable to parse chpt number, not padding")
	}

	return fmt.Sprintf("%s Ch. %s", m.Title(), chapter.Attributes.Chapter)
	// return m.volumeDir(chapter.Attributes.Volume)
}

func (m *manga) ContentPath(chapter ChapterSearchData) string {
	if chapter.Attributes.Volume == "" {
		return path.Join(m.mangaPath(), m.ContentDir(chapter))
	}
	return path.Join(m.mangaPath(), m.volumeDir(chapter.Attributes.Volume), m.ContentDir(chapter))
}

func (m *manga) ContentKey(chapter ChapterSearchData) string {
	return chapter.Id
}

func (m *manga) ContentLogger(chapter ChapterSearchData) zerolog.Logger {
	builder := m.Log.With().
		Str("id", chapter.Id).
		Str("chapter", chapter.Attributes.Chapter)

	if chapter.Attributes.Volume != "" {
		builder = builder.Str("volume", chapter.Attributes.Volume)
	}

	if chapter.Attributes.Title != "" {
		builder = builder.Str("title", chapter.Attributes.Title)
	}

	return builder.Logger()
}

func (m *manga) ContentUrls(chapter ChapterSearchData) ([]string, error) {
	imageInfo, err := m.repository.GetChapterImages(chapter.Id)
	if err != nil {
		return nil, err
	}
	return imageInfo.FullImageUrls(), nil
}

func (m *manga) WriteContentMetaData(chapter ChapterSearchData) error {
	metaKey, metaPath := chapter.Attributes.Chapter, m.ContentPath(chapter)

	if slices.Contains(m.volumeMetadata, metaKey) {
		m.Log.Trace().
			Str("volume", chapter.Attributes.Volume).
			Str("chapter", chapter.Attributes.Chapter).
			Msg("volume metadata already written, skipping")
		return nil
	}

	l := m.Log.With().Str("metaKey", metaKey).Logger()

	err := os.MkdirAll(metaPath, 0755)
	if err != nil {
		return err
	}

	coverURL, ok := m.coverFactory(chapter.Attributes.Volume)
	if !ok {
		l.Debug().Msg("unable to find cover")
	} else {
		l.Trace().Str("url", coverURL).Msg("downloading cover image")
		// Use !0000 cover.jpg to make sure it's the first file in the archive, this causes it to be read
		// first by most readers, and in particular, kavita.
		filePath := path.Join(metaPath, "!0000 cover.jpg")
		if err = m.downloadAndWrite(coverURL, filePath); err != nil {
			return err
		}
	}

	l.Trace().Msg("writing comicinfoxml")
	if err = comicinfo.Save(m.comicInfo(chapter), path.Join(metaPath, "comicinfo.xml")); err != nil {
		return err
	}

	/*l.Trace().Msg("writing MetronInfo.xml")
	if err = m.metronInfo(chapter).Save(path.Join(metaPath, "MetronInfo.xml"), true); err != nil {
		return err
	}*/

	m.volumeMetadata = append(m.volumeMetadata, metaKey)
	return nil
}

//nolint:funlen
func (m *manga) metronInfo(chapter ChapterSearchData) *metroninfo.MetronInfo {
	mi := metroninfo.NewMetronInfo()

	mi.IDS = []metroninfo.ID{
		{
			Source:  metroninfo.SourceMangaDex,
			Primary: true,
			Value:   m.id,
		},
	}

	mi.Series = metroninfo.Series{
		Name:      m.info.Attributes.EnTitle(),
		StartYear: m.info.Attributes.Year,
		AlternativeNames: utils.FlatMap(utils.Map(m.info.Attributes.AltTitles, func(t map[string]string) []metroninfo.AlternativeName {
			var out []metroninfo.AlternativeName
			for key, value := range t {
				out = append(out, metroninfo.AlternativeName{
					Lang:  metroninfo.LanguageCode(key),
					Value: value,
				})
			}
			return out
		})),
	}
	mi.Summary = utils.MdToSafeHtml(m.info.Attributes.EnDescription())
	mi.AgeRating = m.info.Attributes.ContentRating.MetronInfoAgeRating()
	mi.URLs = utils.Map(m.info.FormattedLinks(), func(t string) metroninfo.URL {
		return metroninfo.URL{
			Primary: t == m.info.RefURL(),
			Value:   t,
		}
	})

	if m.totalVolumes == 0 {
		mi.Stories = metroninfo.Stories{{Value: chapter.Attributes.Title}}

		if chapter.Attributes.PublishedAt != "" {
			publishTime, err := time.Parse(timeLayout, chapter.Attributes.PublishedAt)
			if err != nil {
				m.Log.Warn().Err(err).
					Str("chapter", chapter.Attributes.Chapter).
					Msg("unable to parse published date")
			} else {
				mi.StoreDate = (*metroninfo.Date)(&publishTime)
			}
		}
	}

	if m.info.Attributes.Status == StatusCompleted {
		switch {
		case m.totalVolumes == 0 && m.foundLastChapter:
			mi.Series.VolumeCount = m.totalChapters
		case m.foundLastChapter && m.foundLastVolume:
			mi.Series.VolumeCount = m.totalVolumes
		case !m.hasWarned:
			m.hasWarned = true
			m.Log.Warn().
				Str("lastChapter", m.info.Attributes.LastChapter).
				Bool("foundLastChapter", m.foundLastChapter).
				Str("lastVolume", m.info.Attributes.LastVolume).
				Bool("foundLastVolume", m.foundLastVolume).
				Msg("Series ended, but not all chapters could be downloaded or last volume isn't present. English ones missing?")
		}
	}

	mi.Genres = utils.MaybeMap(m.info.Attributes.Tags, func(t TagData) (metroninfo.Genre, bool) {
		n, ok := t.Attributes.Name["en"]
		if !ok {
			return metroninfo.Genre{}, false
		}

		if t.Attributes.Group != genreTag {
			return metroninfo.Genre{}, false
		}

		return metroninfo.Genre{
			Value: n,
		}, true
	})
	mi.Tags = utils.MaybeMap(m.info.Attributes.Tags, func(t TagData) (metroninfo.Tag, bool) {
		n, ok := t.Attributes.Name["en"]
		if !ok {
			return metroninfo.Tag{}, false
		}

		if t.Attributes.Group == genreTag {
			return metroninfo.Tag{}, false
		}

		return metroninfo.Tag{
			Value: n,
		}, true
	})

	roleMapper := func(r metroninfo.RoleValue) func(t string) metroninfo.Credit {
		return func(t string) metroninfo.Credit {
			return metroninfo.Credit{
				Creator: metroninfo.Resource{
					Value: t,
				},
				Roles: []metroninfo.Role{{
					Value: r,
				}},
			}
		}
	}

	authors := utils.Map(m.info.Authors(), roleMapper(metroninfo.RoleWriter))
	artists := utils.Map(m.info.Artists(), roleMapper(metroninfo.RoleArtist))
	scanlation := utils.Map(m.info.ScanlationGroup(), roleMapper(metroninfo.RoleTranslator))

	mi.Credits = utils.FlatMapMany(authors, artists, scanlation)
	mi.Notes = metronInfoNote
	now := time.Now()
	mi.LastModified = &now

	return mi
}

//nolint:funlen
func (m *manga) comicInfo(chapter ChapterSearchData) *comicinfo.ComicInfo {
	ci := comicinfo.NewComicInfo()

	ci.Series = m.info.Attributes.EnTitle()
	ci.Year = m.info.Attributes.Year
	ci.Summary = utils.MdToSafeHtml(m.info.Attributes.EnDescription())
	ci.Manga = comicinfo.MangaYes
	ci.AgeRating = m.info.Attributes.ContentRating.ComicInfoAgeRating()
	ci.Web = strings.Join(m.info.FormattedLinks(), ",")

	ci.Title = chapter.Attributes.Title
	if chapter.Attributes.PublishedAt != "" {
		publishTime, err := time.Parse(timeLayout, chapter.Attributes.PublishedAt)
		if err != nil {
			m.Log.Warn().Err(err).Str("chapter", chapter.Attributes.Chapter).Msg("unable to parse published date")
		} else {
			ci.Year = publishTime.Year()
			ci.Month = int(publishTime.Month())
			ci.Day = publishTime.Day()
		}
	}

	alts := m.info.Attributes.EnAltTitles()
	if len(alts) > 0 {
		ci.LocalizedSeries = alts[0]
	}

	// Add the comicinfo#count field if the manga has completed, so Kavita can add the correct Completed marker
	// We can't add it for others, as mangadex is community sourced, so may lag behind. But this should be correct
	if m.info.Attributes.Status == StatusCompleted {
		switch {
		case m.totalVolumes == 0 && m.foundLastChapter:
			ci.Count = m.totalChapters
		case m.foundLastChapter && m.foundLastVolume:
			ci.Count = m.totalVolumes
		case !m.hasWarned:
			m.hasWarned = true
			m.Log.Warn().
				Str("lastChapter", m.info.Attributes.LastChapter).
				Bool("foundLastChapter", m.foundLastChapter).
				Str("lastVolume", m.info.Attributes.LastVolume).
				Bool("foundLastVolume", m.foundLastVolume).
				Msg("Series ended, but not all chapters could be downloaded or last volume isn't present. English ones missing?")
		}
	}

	if v, err := strconv.Atoi(chapter.Attributes.Volume); err == nil {
		ci.Volume = v
	} else {
		m.Log.Trace().Err(err).Str("volume", chapter.Attributes.Volume).Msg("unable to parse volume number")
	}

	ci.Genre = strings.Join(utils.MaybeMap(m.info.Attributes.Tags, func(t TagData) (string, bool) {
		n, ok := t.Attributes.Name["en"]
		if !ok {
			return "", false
		}

		if t.Attributes.Group != genreTag {
			return "", false
		}

		return n, true
	}), ",")

	ci.Tags = strings.Join(utils.MaybeMap(m.info.Attributes.Tags, func(t TagData) (string, bool) {
		n, ok := t.Attributes.Name["en"]
		if !ok {
			return "", false
		}

		if t.Attributes.Group == genreTag {
			return "", false
		}

		return n, true
	}), ",")

	ci.Writer = strings.Join(m.info.Authors(), ",")
	ci.Colorist = strings.Join(m.info.Artists(), ",")

	ci.Notes = comicInfoNote
	return ci
}

func (m *manga) DownloadContent(page int, chapter ChapterSearchData, url string) error {
	filePath := path.Join(m.ContentPath(chapter), fmt.Sprintf("page %s.jpg", utils.PadInt(page, 4)))
	if err := m.downloadAndWrite(url, filePath); err != nil {
		return err
	}
	m.ImagesDownloaded++
	return nil
}

func (m *manga) ContentRegex() *regexp.Regexp {
	return contentRegex
}

func (m *manga) ShouldDownload(chapter ChapterSearchData) bool {
	download := !slices.Contains(m.ExistingContent, m.ContentDir(chapter)+".cbz")

	// Backwards compatibility check if volume has been downloaded
	if chapter.Attributes.Volume != "" {
		if slices.Contains(m.ExistingContent, m.volumeDir(chapter.Attributes.Volume)+".cbz") {
			download = false
		}
	}

	if !download {
		m.Log.Trace().Str("key", m.ContentKey(chapter)).Msg("content already downloaded, skipping")
	} else {
		m.Log.Debug().Str("key", m.ContentKey(chapter)).Msg("adding content to download queue")
	}
	return download
}

func (m *manga) mangaPath() string {
	return path.Join(m.Client.GetBaseDir(), m.GetBaseDir(), m.Title())
}

func (m *manga) volumeDir(v string) string {
	if v == "" {
		return fmt.Sprintf("%s Special", m.Title())
	}

	return fmt.Sprintf("%s Vol. %s", m.Title(), v)
}

func (m *manga) downloadAndWrite(url string, path string, tryAgain ...bool) error {
	resp, err := m.httpClient.Get(url)
	if err != nil {
		return err
	}
	defer func(Body io.ReadCloser) {
		if err = Body.Close(); err != nil {
			m.Log.Warn().Err(err).Msg("error closing body")
		}
	}(resp.Body)

	if resp.StatusCode == http.StatusOK {
		data, err := io.ReadAll(resp.Body)
		if err != nil {
			return err
		}

		if err = os.WriteFile(path, data, 0755); err != nil {
			return err
		}

		return nil
	}

	if resp.StatusCode != http.StatusTooManyRequests {
		return fmt.Errorf("bad status: %s", resp.Status)
	}

	if len(tryAgain) > 0 && !tryAgain[0] {
		m.Log.Error().Msg("Reached rate limit, after sleeping. What is going on?")
		return fmt.Errorf("bad status: %s", resp.Status)
	}

	retryAfter := resp.Header.Get("X-RateLimit-Retry-After")
	if retryAfter == "" {
		return fmt.Errorf("bad status: %s", resp.Status)
	}

	var d time.Duration
	if unix, err := strconv.ParseInt(retryAfter, 10, 64); err == nil {
		t := time.Unix(unix, 0)
		d = time.Until(t)
	} else {
		d = time.Minute
	}

	m.Log.Warn().Str("retryAfter", retryAfter).Dur("sleeping_for", d).Msg("Hit rate limit, try again after it's over")

	time.Sleep(d)
	return m.downloadAndWrite(url, path, false)
}
