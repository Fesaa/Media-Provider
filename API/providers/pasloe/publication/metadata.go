package publication

import (
	"context"
	"fmt"
	"math"
	"path"
	"slices"
	"strconv"
	"strings"

	"github.com/Fesaa/Media-Provider/config"
	"github.com/Fesaa/Media-Provider/db/models"
	"github.com/Fesaa/Media-Provider/internal/comicinfo"
	"github.com/Fesaa/Media-Provider/utils"
)

const comicInfoNote = "This comicinfo.xml was auto generated by Media-Provider, with information from %s. Source code can be found here: https://github.com/Fesaa/Media-Provider/"

// TODO: Not all content may use ComicInfo and a cover like this.
func (p *publication) writeMetadata(ctx context.Context, chapter Chapter) error {
	url := utils.NonEmpty(chapter.CoverUrl, p.series.CoverUrl)
	if p.req.GetBool(IncludeCover, true) {
		if url != "" {
			filePath := path.Join(p.ContentPath(chapter), "!0000 cover"+utils.Ext(url))
			if err := p.DownloadAndWrite(ctx, url, filePath); err != nil {
				return err
			}
		} else {
			p.log.Warn().Str("chapter", chapter.Id).Msg("no cover url specified")
		}
	}

	return comicinfo.Save(p.fs, p.buildComicInfoForChapter(ctx, chapter), path.Join(p.ContentPath(chapter), "ComicInfo.xml"))
}

func (p *publication) buildComicInfoForChapter(ctx context.Context, chapter Chapter) *comicinfo.ComicInfo {
	ci := comicinfo.NewComicInfo()

	ci.Notes = fmt.Sprintf(comicInfoNote, p.Provider().String())

	ci.Series = p.Title()
	ci.AlternateSeries = p.series.AltTitle
	ci.Summary = utils.NonEmpty(chapter.Summary, p.series.Description)
	ci.Manga = comicinfo.MangaYes
	ci.Title = chapter.Title

	if chapter.Volume != "" {
		if vol, err := strconv.Atoi(chapter.Volume); err == nil {
			ci.Volume = vol
		}
	}

	if chapter.Chapter != "" {
		ci.Number = chapter.Chapter
	} else {
		ci.Format = "Special"
	}

	filter := func(role comicinfo.Role) string {
		return strings.Join(utils.MaybeMap(p.series.People, func(person Person) (string, bool) {
			return person.Name, person.Roles.HasRole(role)
		}), ",")
	}

	ci.Writer = filter(comicinfo.Writer)
	ci.Colorist = filter(comicinfo.Colorist)

	ci.Web = strings.Join(p.series.Links, ",")
	if !slices.Contains(p.series.Links, p.series.RefUrl) {
		ci.Web += fmt.Sprintf(",%s", p.series.RefUrl)
	}

	tags := append(p.series.Tags, chapter.Tags...) //nolint: gocritic
	ci.Genre, ci.Tags = p.GetGenreAndTags(ctx, tags)
	if ar, ok := p.GetAgeRating(tags); ok {
		ci.AgeRating = ar
	}

	count, ok := p.GetCiStatus()

	if !ok {
		return ci
	}

	ci.Count = count
	if p.toggles.Toggled(toggleSubscriptionExhausted) || !p.req.IsSubscription {
		return ci
	}

	p.toggles.Toggle(toggleSubscriptionExhausted)
	p.log.Debug().Msg("Subscription was completed, consider cancelling it")

	body := p.translocoService.GetTranslation("sub-downloaded-all",
		p.series.RefUrl, p.Title(), fmt.Sprintf("%d Items", ci.Count))

	p.notificationService.Notify(ctx, models.NewNotification().
		WithTitle(p.translocoService.GetTranslation("sub-downloaded-all-title")).
		WithSummary(p.Title()).
		WithBody(body).
		WithGroup(models.GroupContent).
		WithColour(models.Primary).
		Build())

	return ci
}

func mapTag(mappings []models.TagMapping, tag string) string {
	tagN := utils.Normalize(tag)

	for _, m := range mappings {
		if m.OriginTag == tagN {
			return m.DestinationTag
		}
	}

	return tag
}

// MapTags transforms all tags as configured by the tag mappings. This method keeps scoped tags, scoped
func MapTags(mappings []models.TagMapping, tags []Tag) []Tag {
	return utils.Map(tags, func(t Tag) Tag {
		val := mapTag(mappings, t.Value)
		id := mapTag(mappings, t.Identifier)

		return Tag{
			Value:      val,
			Identifier: id,
			IsGenre:    t.IsGenre,
		}
	})
}

// GetGenreAndTags returns two comma-separated strings: one for genres and one for tags.
//
// A Tag is considered a genre if:
//   - It is not in the blacklist.
//   - It is mapped as a genre.
//
// A Tag is considered a tag if:
//   - It is not in the blocklist.
//   - It is not mapped as a genre.
//   - It is either in the whitelist or the request has IncludeNotMatchedTagsKey set to true.
func (p *publication) GetGenreAndTags(ctx context.Context, tags []Tag) (string, string) {
	var genres, blackList, whitelist []string
	var tagMappings []models.TagMapping
	preferencesLoaded := p.preferences != nil

	if preferencesLoaded {
		genres = utils.Map(p.preferences.GenreList, utils.Normalize)
		blackList = utils.Map(p.preferences.BlackList, utils.Normalize)
		whitelist = utils.Map(p.preferences.WhiteList, utils.Normalize)
		tagMappings = utils.Map(p.preferences.TagMappings, func(t models.TagMapping) models.TagMapping {
			return models.TagMapping{
				OriginTag:      utils.Normalize(t.OriginTag),
				DestinationTag: t.DestinationTag,
			}
		})
	} else {
		p.log.Warn().Msg("No genres or tags will be set, blacklist couldn't be loaded")

		if !p.toggles.Toggled(togglePreferencesFailed) {
			p.toggles.Toggle(togglePreferencesFailed)
			p.notificationService.Notify(ctx, models.NewNotification().
				WithTitle(p.translocoService.GetTranslation("blacklist-failed-to-load-title", p.Title())).
				WithBody(p.translocoService.GetTranslation("blacklist-failed-to-load-summary")).
				WithGroup(models.GroupContent).
				WithColour(models.Warning).
				WithOwner(p.Request().OwnerId).
				WithRequiredRoles(models.ViewAllDownloads).
				Build())
		}

		if config.SkipTagsOnFailure {
			return "", ""
		}
	}

	tags = MapTags(tagMappings, tags)

	tagContains := func(slice []string, tag Tag) bool {
		return slices.Contains(slice, utils.Normalize(tag.Value)) || slices.Contains(slice, utils.Normalize(tag.Identifier))
	}

	// Not blacklisted, configured as genre or forced
	tagAllowedAsGenre := func(tag Tag) bool {
		return preferencesLoaded &&
			!tagContains(blackList, tag) &&
			(tagContains(genres, tag) || tag.IsGenre)
	}
	// not blacklisted, whitelisted or include all, not a genre
	tagAllowedAsTag := func(tag Tag) bool {
		return preferencesLoaded &&
			!tagContains(blackList, tag) &&
			(tagContains(whitelist, tag) || p.req.GetBool(IncludeNotMatchedTagsKey, false)) &&
			!tagContains(genres, tag) &&
			!tag.IsGenre
	}

	filterTags := func(tags []Tag, f func(Tag) bool) []string {
		return utils.MaybeMap(tags, func(tag Tag) (string, bool) {
			return tag.Value, f(tag)
		})
	}

	filteredGenres := utils.Distinct(filterTags(tags, tagAllowedAsGenre), utils.IdentityFunc[string]())
	filteredTags := utils.Distinct(filterTags(tags, tagAllowedAsTag), utils.IdentityFunc[string]())

	return strings.Join(filteredGenres, ", "), strings.Join(filteredTags, ", ")
}

// GetAgeRating returns the highest comicinfo.AgeRating that is mapped under the models.AgeRatingMappings
// Returns false if no Tag was mapped
func (p *publication) GetAgeRating(tags []Tag) (comicinfo.AgeRating, bool) {
	if p.preferences == nil {
		if p.series.ContentRating != "" {
			return p.series.ContentRating, true
		}
		p.log.Warn().Msg("Could not load age rate mapping, not setting age rating")
		return "", false
	}

	tagMappings := utils.Map(p.preferences.TagMappings, func(t models.TagMapping) models.TagMapping {
		return models.TagMapping{
			OriginTag:      utils.Normalize(t.OriginTag),
			DestinationTag: t.DestinationTag,
		}
	})
	tags = MapTags(tagMappings, tags)

	mappings := p.preferences.AgeRatingMappings
	weights := utils.MaybeMap(tags, func(t Tag) (int, bool) {
		ar, ok := GetAgeRating(mappings, utils.Normalize(t.Value))
		if !ok {
			return 0, false
		}

		return comicinfo.AgeRatingIndex[ar], true
	})

	if len(weights) == 0 {
		if p.series.ContentRating != "" {
			return p.series.ContentRating, true
		}
		return "", false
	}

	return comicinfo.IndexToAgeRating[slices.Max(weights)], true
}

func GetAgeRating(arm []models.AgeRatingMapping, tag string) (comicinfo.AgeRating, bool) {
	ageRating := -1
	for _, ageRatingMapping := range arm {
		if utils.Normalize(ageRatingMapping.Tag) != tag {
			continue
		}

		ageRating = max(ageRating, comicinfo.AgeRatingIndex[ageRatingMapping.ComicInfoAgeRating])
	}

	if ageRating > -1 {
		return comicinfo.IndexToAgeRating[ageRating], true
	}

	return "", false
}

func (p *publication) GetCiStatus() (int, bool) {
	if p.series.Status != StatusCompleted {
		return 0, false
	}

	ts, ok := p.series.TranslationStatus.Get()
	if ok && ts != StatusCompleted {
		return 0, false
	}

	if hv, ok := p.series.highestVolume.Get(); ok {
		return int(hv), true
	}

	if hc, ok := p.series.highestChapter.Get(); ok {
		return int(hc), true
	}

	// Fallback to getting it from chapters
	var highestVolume float64 = 0
	var highestChapter float64 = 0
	for _, chapter := range p.series.Chapters {
		if chapter.Volume != "" {
			highestVolume = math.Max(highestVolume, chapter.VolumeFloat())
		}

		if chapter.Chapter != "" {
			highestChapter = math.Max(highestChapter, chapter.ChapterFloat())
		}
	}

	if highestVolume != 0 {
		return int(highestVolume), true
	}

	if highestChapter != 0 {
		return int(highestChapter), true
	}

	return 0, false
}
